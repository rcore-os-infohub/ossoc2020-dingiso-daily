# DailySchedule
## 日常记录 for Rust and zcore
六月末 AND 七月初

| Mon  | Tues | Wed  | Thur | Fri  | Sat  | Sun  |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      | 27   | 28   |
| 29   | 30   | 1    | 2    | 3    | 4    | 5    |
| 6    | 7    | 8    | 9    | 10   | 11   | 12   |
| 13   | 14   | 15   | 16   | 17   | 18   | 19   |
| 20   | 21   | 22   | 23   | 24   | 25   | 26   |

=======

* [Day 0 (7.3)](#0)  
* [Day 1 (7.4)](#Day001)   
* [Day 2 (7.5)](#Day002)   
* [Day 3 (7.6)](#Day003)  
* [Day 4 (7.7)](#Day004)   
* [Day 5 (7.8)](#Day005)   
* [Day 6 (7.9)](#Day006)   
* [Day 7 (7.10)](#Day007)   
* [Day 8 (7.11)](#Day008)   
* [Day 9 (7.12)](#Day009)   
* [Day 10 (7.13)](#Day010)   
* [Day 11 (7.14)](#Day011)   
* [Day 12 (7.15)](#Day012)   
* [Day 13 (7.16)](#Day013)   
* [Day 14 (7.17)](#Day014)   
* [Day 15 (7.18)](#Day015)   
* [Day 16 (7.19)](#Day016)   
* [Day 17 (7.20)](#Day017)   
* [Day 18 (7.21)](#Day018)   
* [Day 19 (7.22)](#Day019)   
* [Day 20 (7.23)](#Day020)   
* [Day 21 (7.24)](#Day021)   
* [Day 22 (7.25)](#Day022)   
* [Day 23 (7.26)](#Day023)   
* [Day 24 (7.27)](#Day024)   
<span id="0"></span>
## Day 0

### 事件1： 学习Rust基础知识

《Rust编程之道》 第二章 语言精要 - 2.1 - 2.7

研究清楚关于 Rust的 <kbd> ownership</kbd>

### 事件2：完成rustlings 部分练习
<img src="https://github.com/dingiso/DailySchedule/blob/master/img/Day1.png?raw=true" alt="rustlings部分练习" width="40%" height="40%" />

### 问题：

**如何 选取重要的部分 赋予更多的精力 ， 而 繁杂的部分在实践中融会贯通？**

Rust 内容过于繁杂， 从面向对象的半编译半解释性 java 编程语言 到  编译型语言 Rust ，我试着通过安全的角度 或者 实用的角度去逐渐思考 为什么 要去 定义这样一个变量，定义成什么类型，怎样去表示他等方面，我还记得 老师 告诉我们 8/2 原则，学一门语言的 20% 常用的部分，而在实际中扩展自己的剩下80%。 但Rust试图将他的全部展现给我，我试着不断去理解，也探索了很多。

### 预计计划：  

1、学习剩下的 常用集合 ，智能指针 ， 泛型和trait  
2、完成 rustlings 的 剩下部分内容
3、温习 操作系统的 相关内容 

<span id="Day001"></span>

## Day 1

### 事件1： 学习Rust基础知识

《Rust编程之道》 第二章 语言精要 - 完成

[用Rust写操作系统](https://learningos.github.io/rcore_step_by_step_webdoc/#从零开始写-os)

### 事件2：完成rustlings 全部练习

<img src="https://github.com/dingiso/DailySchedule/blob/master/img/Day2.png?raw=true" alt="rustlings全部练习" width="40%" height="40%" />

### 问题：

**rust 教程中有哪些重点和操作系统需要用到的相关，需要学习的比较深入？**

### 预计计划：  

1、精通完善 模块 ，macro_rules! , 
2、利用 rust 完成 中长练习题
3、温习 操作系统的 相关内容、

<span id="Day002"></span>

## Day 2

### 事件1： 学习Rust基础知识

《Rust编程之道》 第三，四，五章  - 粗略看完

 Rust视频教程部分基础部分-看完-巩固复习

[Rust编程视频教程](https://www.bilibili.com/video/BV1xJ411B79h?from=search&seid=11648763424608637522)

### 事件2：对基础知识部分进行总结，形成xmind 文件

<img src="https://github.com/dingiso/DailySchedule/blob/master/img/Rust.png?raw=true" alt="rust总结" width="40%" height="40%" />

### 问题：

Rust 中 的 **Error E5020** 的相关问题

### 预计计划：  

1、细看剩下的章节 
2、利用 rust 完成 中长练习题
3、温习 操作系统的 相关内容

<span id="Day003"></span>

## Day3

### 事件1： 学习Rust基础知识

重点阅读《Rust编程之道》 第三、四、五章，理解类型系统和所有权；第九章，理解错误处理； 第十三章，理解Unsafe Rust）

 Rust视频教程部分基础部分-看完-巩固复习

[Rust编程视频教程](https://www.bilibili.com/video/BV1xJ411B79h?from=search&seid=11648763424608637522)

### 事件2：完成《Rust编程之道》第十章



### 解决问题：

Rust 中 的 全局变量，可变全局变量的声明

### 预计计划：  

1、细看剩下的章节 
2、利用 rust 完成 中长练习题
3、温习 操作系统的 相关内容

<span id="Day004"></span>
## Day4

### 事件1： 练习Rust

完成leetcode 5道练习题

### 事件2：读RISC-V 官方文档



### 解决问题：

Rust 中 linkedlist 等的数据结构

### 预计计划：  

1、进入RISC-v
2、利用 rust 完成 中长练习题
3、温习 操作系统的 相关内容

<span id="Day005"></span>

## Day5

今天有考试 ， 复习了一天 :blonde_woman:

<span id="Day006"></span>
## Day6

### 事件1： 读完 计算机组成原理 RISC-V 前两章

[读书笔记](https://github.com/dingiso/DailySchedule/blob/master/docs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1RISC-V.md)

### 事件2： 看 浙大 的视频



### 解决问题：

Rust 中的 生命周期的内容

### 预计计划：  

1、继续研究RISC-v
2、利用 rust 完成 中长练习题
3、温习 操作系统的 相关内容

<span id="Day007"></span>

## Day7

### 事件1： 看RISC-V 特权级指令相关内容



### 事件2： 每日一题

[地下城游戏](https://leetcode-cn.com/problems/dungeon-game/solution/zhi-guan-jie-fa-by-dingiso/)
[源文件](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/174_%E5%9C%B0%E4%B8%8B%E5%9F%8E%E6%B8%B8%E6%88%8F.rs)

### 解决问题：

Rust 中的 

### 预计计划：  

1、继续研究RISC-v
2、温习 操作系统-物理内存管理 的 相关内容

<span id="Day008"></span>

## Day8

### 事件1： lab-0

1. 为了借用新的特性 nightly
2. std 依赖操作系统 `#![no_std]` 禁用
3. `panic_handler` 也在std库中，但是在运行过程中必须实现，所以我们自己写一个
4. 异常时是要通过堆栈反向**捕获异常**并**清理现场**的，暂时不需实现，所以panic直接终止
5. `main`函数并不能作为操作系统入口，所以我们用`_start` 函数代替，并利用 `extern "C"` 和 `# [no_mangle]` 来使得他成为入口函数
6. 通过改变链接器参数，使得程序编译成不依赖其他运行时环境的裸机目标
7. 对于一个OS内核，他的起始地址和普通程序不同，在高地址上，通过更改-链接脚本
8. 通过更改链接脚本使得，内核放在正确的地址上，并依次按顺序排放，`_start` 在先.
9. 内核运行还需要环境支持，所以我们用汇编重写`_start` ，分配启动栈，并跳转到内核入口
10. 将汇编代码内联到`main.rs`中，并更改内核入口为`rust_main`
11. 建立`Makefile` 保存编译运行参数，方便直接调用运行
12. OpenSBI 所提供的`SBI`调用参数 **0-8** ，为我们提供操作操作系统的基本功能
13. 输出功能利用`core`中的输出函数调用`SBI`的单字符输出，并利用`println`等宏进行封装
14. 完善 `panic` 和 `abort` 功能

### 事件2： 每日一题

[不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/solution/jie-ti-si-lu-by-dingiso/)
[源文件](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/96.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.rs)

### 解决问题：

Rust 中的 生命周期的内容

### 预计计划：  

1、继续研究RISC-v
2、温习 操作系统-虚拟存储 的 相关内容

<span id="Day009"></span>

## Day9

### 事件1： 总结一周的内容，参加研讨



### 事件2： 每日一题

[两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/zui-la-ji-dai-ma-mei-you-zhi-yi-by-dingiso/)
[源文件](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/350.%20%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86%20II.rs)

### 解决问题：

gdb 调试时， make debug 不成功， 修改debug 值 留下 -s -S 内容 ， 自行打开 gdb调试
### gdb常用命令总结
**list(简写 l)**  ： 查看源程序代码，默认显示10行，按回车键继续看余下的
**list 行号**：将显示当前文件以“行号”为中心的前后10行代码，如：list 12
**list 函数名**：将显示“函数名”所在函数的源代码，如：list main
**list ：不带参数**，将接着上一次 list 命令的，输出下边的内容。

**break(简写 b)** ：格式 b 行号，在某行设置断点；
**b fn1 if a＞b**：条件断点设置
**break func（break缩写为b）**：在函数func()的入口处设置断点，如：break cb_button
**delete n**：删除第n个断点
**disable n**：暂停第n个断点
**enable n**：开启第n个断点
**clear n**：清除第n行的断点
**delete breakpoints**：清除所有断点：

**info b （info breakpoints）** ：显示当前程序的断点设置情况
* Num： 断点编号
* Disp：断点执行一次之后是否有效 kep：有效 dis：无效
* Enb： 当前断点是否有效 y：有效 n：无效
* Address：内存地址
* What：位置

**run （简写 r）** ： 其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。
**continue（简写 c)** ： 继续执行程序，直到下一个断点或者结束；
**next（简写 n )** ：单步执行程序，但是遇到函数时会直接跳过函数，不进入函数；
**step(简写 s)** ：单步执行程序，但是遇到函数会进入函数；
**until**：运行程序直到退出循环体；
**until+行号**： 运行至某行，不仅仅用来跳出循环；
**finish**： 运行程序到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息；
**call 函数(参数)** ：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)；
**quit：（简记为 q） ** ：退出gdb；

**print、whatis** + 变量名 ： 查看变量


### 预计计划：  

1、lab-1
2、总结 lab-0 的代码，形成体系

<span id="Day010"></span>

## Day10

### 事件1： lab-1

1. 中断处理首先要保存上下文(即寄存器)在栈中,并在中断后恢复,分为两部分: 
   * context :通用32个寄存器,保存触发中断的指令地址`sepc`和系统状态的`sstatus`
   * 单列 :保存中断主要信息和原因的 `scause` 和 `stval`,因为后面需要使用所以单独
2. 利用汇编将寄存器的值存储在栈中,注意栈寄存器`sp`就是`x2`,所以需要空出他
3. 利用 `STIE` 位开启时钟中断,利用 `sstatus` 的 `SIE` 位,允许内核态被中断打断
4. 通过`sbi_call` 可以预约下一次的时钟中断,`time`参数就是中断时间
5. 总结 时钟中断的调用过程

### 事件2： 每日一题

[正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching) 

### 解决问题：

回看  risc -v 的寄存器 架构 ，与 MSU 三种模式

### 预计计划：  

1、总结 lab-1 的内容
2、温习 操作系统-中断 的 相关内容

<span id="Day011"></span>

## Day11

### 事件1： lab-1

完成实验题

<image src="" alt="" />

### 事件2： 每日一题

[判断二分图](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/785.%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE.rs) 

### 解决问题：

sbi 中的中断的情况及其作用

### 预计计划：  

1、总结 lab-1 的内容
2、温习 操作系统-中断 的 相关内容

<span id="Day012"></span>

## Day12 ,13,14

17 号考科三， 备战科三 + 一门考试

<span id="Day013"></span>

<span id="Day014"></span>

<span id="Day015"></span>

## Day15

### 事件1： lab-2 动态内存分配

1. 对于动态内存分配，我们需要实例一个`堆`对象，而这个对象必须具有以下特征

   * 实现 `Trait GlobalAlloc` 的分配功能
     * 实现 `alloc` 和 `dealloc` 函数  ， 要求分配连续`size`大小，满足`align`对齐
   * 使用语义项`#[global_allocator]`进行标记

   编译器便会自动使用我们提供的内存分配函数

2. 先开辟一个`u8`数组，将首地址和长度付给我们定义好的堆对象即可

3. 探寻内核使用的结尾地址，`linker.ld` 说明了结尾地址为 `kernel_end` 我们将此函数实现，并将他的地址 作为 `usize` 输出皆可。

<image src="" alt="" />

### 事件2： 每日一题

[97. 交错字符串](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/97.%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2.rs)

### 解决问题：

回看  risc -v 的寄存器 架构 ，与 MSU 三种模式

### 预计计划：  

1、总结 lab-1 的内容
2、温习 操作系统-中断 的 相关内容

<span id="Day016"></span>

## Day16

### 事件1： 参加 每周一次的研讨会

参加组织的会议，了解到了很多相关的内容，着重的

### 事件2： 每日一题

[312.戳气球](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/312.%E6%88%B3%E6%B0%94%E7%90%83.rs)

### 事件3： 完成lab2

实现了内存的动态分配

<img src="https://github.com/dingiso/DailySchedule/blob/master/img/Day17-1.png?raw=true" alt="内存的动态分配" width="40%" height="40%" />

探测了内核的结尾地址

<img src="https://github.com/dingiso/DailySchedule/blob/master/img/Day17-2.png?raw=true" alt="探测了内核的结尾地址" width="40%" height="40%" />

### 总结：  

#### 物理页的管理与分配

1. 页首地址满足 4kB 的倍数 ，页号 x4096 = 页首地址

2. 分配的地址不存在堆或栈中，我们利用`FrameTracker`封装，实现类似于`Box` 的智能指针的相关特性，相当于我们对**页**实现了以下操作：

   * 封装了 `&'static mut` 类型的引用
   * 提供了 `Drop` 函数，存在生命周期，超出后自动析构
   * 需要引用计数则外面封装 [`Arc`](alloc::sync::Arc) 

3. 针对所有的物理页，我们实现了一个物理页分配器封装对页的操作

   ```rust
    pub static ref FRAME_ALLOCATOR: Mutex<FrameAllocator<AllocatorImpl>> = Mutex::new(FrameAllocator::new(Range::from(PhysicalPageNumber::ceil(PhysicalAddress::from(*KERNEL_END_ADDRESS))..PhysicalPageNumber::floor(MEMORY_END_ADDRESS),)));
   ```

   **`Mutex<FrameAllocator<AllocatorImpl>>`** 

   * `Mutex`对分配器加锁防止多个线程访问，

   * `FrameAllocator` 为主要分配器，

   * `AllocatorImpl` 为分配器算法。

   `PhysicalPageNumber::ceil(PhysicalAddress::from(*KERNEL_END_ADDRESS))..PhysicalPageNumber::floor(MEMORY_END_ADDRESS)`

   分配器分配的内存范围从 `kerne_end` 结束（上取整）开始到 我们可访问内存的最后的（下取整）

4. 分配器算法利用的是实际物理页和起始地址的偏移量

<span id="Day017"></span>

## Day17

### 事件1： 钻研lab-3的内容

### 基础内容 - 关于页表

### 首先： 为什么要用到虚拟地址？

简单理解，这是为了方便程序编写者的一种方法。比如我的程序想要运行在这个操作系统上， 我希望不需要考虑操作系统的实际内存情况，难道我还要看一下操作系统的代码，或翻一下手册么？ ， 我希望我的程序用的就是从 `0x1` 开始的连续地址，那么这个 `0x1` 就是虚拟地址。

### 页表：

但是在操作系统中，实际运行时是需要使用实际物理地址的，那么我们如何推算物理地址呢，我们可以将这种（虚拟地址-物理地址）看作一种函数（映射）关系
`f (虚拟地址）= 物理地址` 在存储时 就有了两种储存的方法，

1. 第一种 我们将这个 `f` 函数（简单理解是个线性的）关系储存下来 - 也就是 最开始[修改内核](https://rcore-os.github.io/rCore-Tutorial-deploy/docs/lab-3/guide/part-2.html) 中使用的方法， 只需要统一加一个 偏移量即可。
2. 第二种 我们将每一个 （虚拟地址-物理地址） 也就 (x,y) 按对存储起来，通过查找 虚拟地址，便能获得相应的物理地址。

第二种方法便是我们所说的页表 ， 他是一（多）张，存储这种关系的表，通过查表便能完成 查找物理地址的任务。

> 而且，虚拟地址也是对物理的地址的一种封装方法，可以实现内核对物理地址的权限管理，也就是我们在页表项的标志位，假设我不希望系统内核所在的地址被其他人写入其他内容，我只需要在页表项上

### 多级页表：

这种方法主要是为了节省内存，同时可以方便我们不用跨物理页去查询这张表。那么他为什么可以节省内存呢？
**举个小栗子：** 内核代码在虚拟地址里 是 `0xffffffff80200000` ， 在实际物理地址是 `0x80200000` ， 在普通页表中我要这么存储， `(0xffffffff80200000,0x80200000,flag)` 这样的。同样在表示内核以 0xffffffff 开头的虚拟地址还有很多，这样会无形中增加很多的空间开销，但我们知道不断存储 `0xffffffff` 是冗余的。所以我们利用分级的方法，可以把页表变成下面的形式（理解方法）：

- 二级页表 `（0xffffffff（虚拟地址的高位），存储下面一级页表的物理页号（首地址） ）`
- 一级页表 `（0x80200000（低位），0x80200000（物理地址））`
  通过二级页表查找到一级页表的存储位置，再通过低位找到对应的物理地址。

**那么**我们实际上对于所有 以开头 `0xffffffff` 开头的虚拟地址，二级页表中永远只有一个页表项，这就节省了原来每次都要把他写上的空间。



### 事件2： 每日一题

[167. 两数之和 II - 输入有序数组](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/167.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.rs)

### 事件3：

### 预计计划：  

1、继续 lab-3 的进程
2、lab-3 实验

<span id="Day018"></span>

## Day18

### 事件1： 完成lab-3

1. 更改 linker.ld 的数据存放起址改为虚拟地址，并在各字段加入对齐，使得一个虚拟页不会有两个段。目的是为了可以对每一个段赋予不同的属性

2. entry.asm 中利用  下面代码使得 CPU模式 变为 Sv39

   ```assembly
   # 8 << 60 是 satp 中使用 Sv39 模式的记号
       li t1, (8 << 60)
       or t0, t0, t1
       # 写入 satp 并更新 TLB
       csrw satp, t0
   ```

   

3. 给出内核使用线性映射的偏移量 并 在 entry.asm 中 建立一个boot_page_table 作为初始页表，

   * 第一个映射是 0x8000_0000 -> 0x8000_0000 VPN3 是 10B 所以放在第三位
   * 第二个映射是 0xffff_ffff_8000_0000 -> 0x8000_0000 VPN3 是 111111110B 所以放在 510位
   * 保存第一个映射是违反规则的，但是为了执行 这个asm内的代码，所以要存在这个映射。

4. 将虚拟地址 分为 `0..9 的VPN1` `9..18的VPN2` `18..27的VPN3`

5. **页表项  ：PageTableEntry = 标志位+页号**   |对 物理页号进行封装

6. **页表 ：PageTable** |装满一个物理页的页表项数组

7. **页表智能指针：PageTableTracker** 因为页表太大了，所以利用上文提供的工具 `FrameTracker` ，将这个页表当成一个物理页看待，利用“智能指针”对其进行操作。

8. **内存段：Segment** |在很多情况下虚拟页的单位量级太小了，我们对内存的管理可能一次涉及很多页，为了简化操作，我们将很多虚拟页统一封装为一个`Segment`，它具有以下属性

   * 两种简单的映射类型 ： 线性映射 和 每一帧都有映射
   * 映射到的一块连续的虚拟地址
   * 统一的权限标识

9. **实际应用的映射关系：Mapping** | 完成了基础的结构定义，那么我们该实际的对每个线程的映射关系进行封装并完成实际的操作和结构了：

   * 保存了 页表向量 ， 根页表物理页号， 映射信息
   * `find_entry()` 实现 给定虚拟页号查找物理页号
   * `map()` 实现了实际数据（未写入页中）的写入并构建映射
     * 线性则利用 我们`address.rs` 中规定的方式直接转换
     * `Framed` 则 分割数据 ， 更新页表，写入物理页， 将映射关系写入映射
   * `activate()` 实现了将页表起使地址写入`satp` ，使用`Sv39`模式并 刷新`TLB`

10. **实现内核的重映射 ：MemorySet** ： 利用我们工作替代原来的蛮夷，

### 事件2： 每日一题

[95. 不同的二叉搜索树 II](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/95.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%912.rs)

### 事件3： 小的提议记录

lab-1 程序运行状态 Context 推荐加入源文件的注释 , 并去掉 `Scause` 的use

> 发生中断时，保存的寄存器
>
> 包括所有通用寄存器，以及：
>
> - `sstatus`：各种状态位
>
> - `sepc`：产生中断的地址
>
> ### `#[repr(C)]` 属性
>
> 要求 struct 按照 C 语言的规则进行内存分布，否则 Rust 可能按照其他规则进行内存排布



### 预计计划：  

1、开始进行 lab-4
2、加油！！

<span id="Day019"></span>

## Day19

### 事件1： 钻研lab-4

1. **线程：Thread** | 线程是我们关注的实际**执行代码的单位**，教程的定义包括

   * 线程 ID  - 唯一标识线程的身份

   * 线程的栈 - 线程占有一段的虚拟空间来进行利用

   * 所属的进程

   * 代表自身情况的可变变量（`Mutex`）- 包括 运行上下文，是否休眠，结束等属性 ， 

     > 利用 `Mutex` 来包装使得 `Arc<Thread>` 保存的线程中的这些值可以被我们使用。

2. **进程： Process** | 资源调度的基本单位，只需要保存自身属性和 线程共享页表，内存空间即可

   * 属于 用户态 还是 内核态
   * 共用的 一块 内存空间，页表

3. **线程管理器：Processor** | 存放和管理所有的线程，主要包括：

   * 正在执行的线程
   * 调度器 对线程实现调度，包括线程的添加，移除，进行下一个
   * 休眠线程-处于等待状态的一些线程

   实现全局的，由`Lock`封装的管理器，我们利用`Mutex`和 `关闭时钟中断`  保证他一直在线

4. 通过设置`Context`进行一个小的实验，进行验证并执行

   * `mv sp a0`  ,  通过 `__restore` 传入一个参数-即我们精心涉及的`Context`
   * 原来我们是在实验中为了验证中断而开启了中断，现在我们将其放在了线程开始时

5. **中断处理** ： |   线程切换实际为时钟中断的过程，我们需要在中断处理时完成切换

   * 定义的管理器`PROCESSOR`完成当前线程的 上下文 的保存
   * 管理器为我们分配下一个应该调用的进程，并将他的上下文返回 通过 `__restore` 转换
     *  如果没有下一个线程，则启动休眠线程，都没有则退出

6. **线程的结束：**| 通过设置 `ra` 时线程顺利结束 

   * 原来线程结束触发`Exception::InstructionPageFault`  ，跳转 `0x0`
   * 通过触发中断，通知操作系统进行释放，`ecall` 调用 `ebreak`
   * 将中断包装在结束函数中，标记线程结束，并设置线程结束的 `ra`

7. **内核栈：** | 但发生中断时，会切换到内核态，原来用于处理中断的`sp`指针需要一个内核栈，专门用于在内核态执行函数 - 防止线程的崩溃导致操作系统的崩溃

   * 只需要一个内核栈，因为只有中断时使用内核栈，而不会有两个线程同时中断

   * 内核栈的地址不能放在通用寄存器中，而`sscratch`只有内核态能访问，比较合适

   * 实际的做法: 定义`kernel_stack`分配空间，`interrupt.asm`中对`sscratch`操作

     * 为内核栈分配一段空间
     * 运行线程时，将内核栈指针保存在`sscratch`寄存器中
     * 中断时，则从将 `Context` 压入 `sscratch` 指向的栈中（`Context` 的地址为 `sscratch - size_of::<Context>()`），同时用新的栈地址来替换 `sp`（此时 `sp` 也会被复制到 `a0` 作为 `handle_interrupt` 的参数）
     * 从中断中返回时（`__restore` 时），`a0` 应指向**被压在内核栈中的 `Context`**。此时出栈 `Context` 并且将栈顶保存到 `sscratch` 中

      运行时如何 将内核栈指针保存在`sscratch`中?

### 事件2： 每日一题

[剑指 Offer 11. 旋转数组的最小数字](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/%E5%89%91%E6%8C%87offer11.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97.rs)

### 事件3： 待定

### 预计计划：  

1、继续 lab-4 的进程
2、lab-4 实验

<span id="Day020"></span>

## Day20

### 事件1： lab-4 的图片形式总结

### 事件2： 每日一题

[64. 最小路径和](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/64.%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.rs)

### 事件3： lab-4 实验题

1. 原理：线程切换之中，页表是何时切换的？页表的切换会不会影响程序 / 操作系统的运行？为什么？

   1）线程结束时，ra 结束函数触发时钟中断，中断处理函数调用 `prepare_next_thread()` , 在实际调用 `next_thread.prepare()`  最后通过 `activate()` 激活页表，进行页表的切换

   2）不会影响运行，页表切换发生在中断期间，操作系统运行中，我们设立了内核栈，中断期间调用的，一直存在。

2. 设计：如果不使用 `sscratch` 提供内核栈，而是像原来一样，遇到中断就直接将上下文压栈，请举出（思路即可，无需代码）：

   - 一种情况不会出现问题    - 不操作 sp 
   - 一种情况导致异常无法处理（指无法进入 `handle_interrupt`）- 不保存 sp 寄存器
   - 一种情况导致产生嵌套异常（指第二个异常能够进行到调用 `handle_interrupt`，不考虑后续执行情况） - 运行两个线程。在两个线程切换的时候，会需要切换页表。但是此时操作系统运行在前一个线程的栈上，一旦切换，再访问栈就会导致缺页，因为每个线程的栈只在自己的页表中
   - 一种情况导致一个用户进程（先不考虑是怎么来的）可以将自己变为内核进程，或以内核态执行自己的代码 -  通过 改变 sp 的存储位置， 使得用户进程有能力访问并修改到

3. 实验：当键盘按下 Ctrl + C 时，操作系统应该能够捕捉到中断。实现操作系统捕获该信号并结束当前运行的线程（你可能需要阅读一点在实验指导中没有提到的代码）

   [handler.rs](https://github.com/dingiso/DailySchedule/blob/master/code/实验四/handler.rs)

    通过开启外部中断的方法， 借助 sbi 调用函数，捕捉键盘导致的外部中断，先在  中断处理时打印 ctrl+c 的 sbi 调用返回值，为3 ，判断其为 3 则 `kill_current_thread`

### 预计计划：  

1、开始 lab-5

<span id="Day021"></span>

## Day21

### 事件1： 钻研lab-5

1. 不能一直运行内核 ，我们要实现把读取存储设备的数据，**OpenSBI** 进行扫描并设备通过**MMIO**映射到物理内存的一块了，我们只需要在rust_main 中添加参数，OpenSBI 就会告诉我们映射的地址

   * `_hart_id`:  0,

     `dtb_pa`:  PhysicalAddress(0x82200000)

2. 通过调用 rcore 中的 属性解析`device_tree`库，我们得到的便是一个 建好的树  - **设备树**

   * 通过 递归 从根节点进行递归 ，发现支持 `"virtio,mmio"` ， 就可以加载他的驱动
   * 初始化设备 时需要进行验证`Magic Number` ， 确定其为设备树

3. 进一步对节点进行判断， 只读取其中的 `Block` 块设备

   * 粒度 为 整**块**，以块为单位读写，（类比硬盘）

4. 实现为 `DMA` 分配物理页的定义和操作 包括 **物理地址-虚拟地址的转换**， **分配和去配操作**

5. 抽象设备 驱动的接口 ，简单的三种方法 ：

   * 读取设备信息
   * 块设备接口
     * 读取某个块 到 buffer 中， 实现对数据的读取
     * 将 buffer 的数据 写入 某个块， 实现写数据

6. 对块设备的抽象，基本为实现上述 的 三个接口。

7. 文件系统 利用 rcore-fs 通过查找全部设备驱动中的第一个存储设备作为根目录。

8. 同时调用`BlockCache::new()` 使得设备在内存中具有`cache`

9. 最后 通过 调用 以实现的接口中的 `ls` 进行 文件名的输出

### 事件2： 每日一题

[1025. 除数博弈](https://leetcode-cn.com/problems/divisor-game/)

### 事件3：  实验4 的fork函数的编写

有点失败，伤心  :cry:

### 预计计划：  

1、继续 lab-6

<span id="Day022"></span>

## Day22

### 事件1： 钻研lab-6

1. 建立 `user` crate，作为用户程序的放置位置 - 并为其去除依赖

2. 通过 `rcore-fs-fuse` 将我们的用户程序编译打包为 **ELF** 文件-转换为 **QCOW_FILE** 格式

3. 利用 `xmas_elf` 解析器将 ELF 文件读到内存中，解析字段，建立**内核映射**（能中断）

4. 修改`Mapping::map` 函数 ， 增加 `init_data`参数为初始化数据
   * 动态分配内存 - 分配的不一定连续 - 利用**帧分**配的方式
   * 考虑 如果最后剩下的数据不满足一页的情况
   * 加载到内存时， 对 `.bss` 段进行初始化

5. 利用汇编参数的传递，实现系统调用，从相应的寄存器中取出调用代号和参数，根据调用代号，进入不同的处理流程，得到处理结果

   * 回数值并继续执行：
     * 返回值存放在 `x10` 寄存器，`sepc += 4`，继续此 `context` 的执行

   * 程序进入等待
     * 同样需要更新 `x10` 和 `sepc`，但是需要将当前线程标记为等待，切换其他线程来执行

   * 程序终止
     * 不需要考虑系统调用的返回，直接删除线程

6. 编写文件的输入输出流 `stdin` `stdout`
7. 实现条件变量，替代原来的阻塞式，增加处理器利用率，增强交互性

### 事件2： 每日一题

[410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)

### 预计计划：  

1、进行总结

<span id="Day023"></span>

## Day23

### 事件1： 对rCore 的第一阶段进行总结

### 事件2： 每日一题

[329. 矩阵中的最长递增路径](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/329.%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E8%B7%AF%E5%BE%84.rs)

### 预计计划：  

1、继续 lab-2 的进程
2、

<span id="Day024"></span>

## Day24

### 事件1： 整理rCore 学习过程中的文档

[所有涉及的文档](https://github.com/dingiso/DailySchedule/tree/master/docs)

### 事件2： 每日一题

[392.判断子序列](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.rs)

#### 事件3： 看lab-6 实验
继续进行lab-6 的实验题 冲冲冲！！！

#### 尾声

希望接下能进入第二阶段的实习吧。

<span id="Day025"></span>
## Day25

### 事件1： 每日一题
[104. 二叉树的最大深度](https://github.com/dingiso/DailySchedule/blob/master/code/Leetcode-Exercize/104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.rs)
<span id="Day026"></span>

















### 计划和总结

### VMO

主要的类型 ： 

* VMObjectPaged : 主要的VMO ， 掌控一组物理页面
  * 父节点
  * 掌控的物理页面
  * 映射关系
  * 标志位  **高速缓存策略**  **pin_count** 等

* VMObjectPhysical ：代表一段连续物理内存

* VMObjectSlice : 物理内存切片

树状结构 ：

* 利用 父节点的 偏移量 和 页面限制来实现
<img src="https://github.com/dingiso/DailySchedule/blob/master/img/VMObject.png?raw=true" alt="rustlings部分练习"  />

### 简化

对树结构的 简化

包括 曾经， **copy_on_write**  利用 一位标志位实现，并调整可读写为，实现不可写，最终在 pagefault的时候在进行 **copy**

**到**

直接 **copy**

### 单元测试

完善 `VMO` 部分的 **单元测试**

### 目标

总觉得 Tutorial 对于 学生的理解有点生涩
我的计划是按照学长的计划
* 视频**报告** 
* 基础知识的介绍
* 代码 和 测试的编写
* 总结
