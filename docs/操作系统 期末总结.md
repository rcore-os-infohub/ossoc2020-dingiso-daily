# 操作系统 期末总结

#### 过程  ---- 算法

设备涉及数据机构：设备控制表DCT ；控制器控制表COCT；通道控制表CHCT；系统设备表SDT

作业 - 平日练习

计算机概述 ： 选择

处理器 ： 内核模式，用户模式，中断

处理器管理：进程，程序区别，为什么提出进程，进程状态转换，进程管理（创建）原子操作

线程： 为什么提出线程，线程和进程区别在哪里，用户级线程，内核级线程，多线程的混合实现（CPU调度）

存储：物理内存，（连续，离散），页式管理 寻址，段页区别，管理

设备：I/O子系统，缓冲区，SPooling，脱机 ，磁盘调度

文件：文件逻辑结构，物理结构，目录结构，目录管理，辅存空间

PV操作，霍尔管程

死锁



大题：

* PV操作，生产-消费同步 ， 读者写者问题，练习题（基础知识 掌握信号量）
  * 死锁避免，银行家算法，其他死锁检测算法，单资源 ，资源分配图
* 段页式管理 工作原理，缺页替换算法
* CPU调度算法
* 磁盘调度算法

### 并发程序设计

程序执行的外部顺序性（多个程序执行有序） 和 内部顺序性（程序CPU执行有序）

临界区 - 程序段，多个进程停留在相关临界区则出现错误

临界区之多有一个进程，不能无限停留，不能无限等待进入

进临界区 关中断，出临界区 开中断

用户程序 ：信号量 PV原语，

semaphore ： 值为可几个进程进入临界区，具有等待进程队列 

p 操作 v操作 一一匹配

同步关系 决定 几个信号量

一生产一消费多缓冲 ： 两个信号量sput sget 一个k缓冲队列，两循环队列指针

多生产多消费： 多个进程共享 循环队列指针，对指针增加两个信号量

管程过程 互斥调用

#### 死锁

四个必要条件： 互斥，占有和等待，不剥夺，循环等待

死锁的防止： 

* 破坏第一个条件：独占型资源 改造成 共享型资源
* 破坏三 ：剥夺式调度
* 破坏四：层次分配
* 预分配 ：

死锁的避免：银行家算法

死锁的检测：Warshall传递闭包 ，检测后，重启或 检验点重启

### 文件管理

文件物理结构 ：

* 顺序文件：数组 - 快速存取 ｜预先分配空间，不易增删改
* 连接文件：链表 - 连接字（指针）为0结尾 ，易于增删改 ｜需要额外空间，仅顺序
* 直接文件：hash散列
* 索引文件：《key，value》-索引区，数据区 链表拓展 ｜需要查两次

文件目录：

* 一级，用户文件众多，容易重名，不利记忆
* 二级， 用户-文件目录。按用户 有用户权限
* 树形，可重名，有权限 路径名为根到结点

文件查找：

* 查找项：文件路径名 
* 查找法：顺序，二分，文件名变换成唯一值“杂凑法”
* 活动文件表： 
  * 多目录访存，多次访问存储器开销大，将常用，正用复制进主存
  * 保存文件目录信息而不是全部信息，能一步找到文件

文件的安全与保护

* 共享（用户权限），保护（防破坏），保密（防窃取）
* 保密措施：隐蔽文件目录，设置口令，使用密码
* 保护措施：副本，存取表（存用户-属性），属性

文件的存取

* 顺序存取：读指针（可跳），写指针
* 直接存取：对记录进行操作，hash
* 索引存取：按键存取

文件的使用

* 两类接口： 操作文件整体，读写等对文件本身
* 建立文件：建立文件目录项-分配物理块-申请活动文件表-登记表-返回文件句柄
* 撤销文件：关闭文件-联访-删去目录项-释放空间
* 打开文件：申请活动文件表项-查找文件-复制到表项-共享文件处理-返回句柄
* 关闭文件：表项“用户数” -1
* 读写文件：找到 逻辑记录- 变为 物理快
* 定位文件：调整读写指针位置

辅存空间管理

* 连续分配：访问速度快，定时“碎片”整理“
* 非连续：空间管理效率高，便于文件动态增长，收缩
* 位示图：空闲块管理  - 高速分去配
* 

## IO设备

操作系统  与 控制器 交互，而非与设备交互

IO控制方式

* 轮询
* 中断 CPU负责发出I/O命令，响应中断 ｜控制器负责检查状态 就绪后发送中断
* DMA 中断的活由DMA执行 CPU只在数据传送开始（初始化DMA）结束（响应中断，不必保护现场）参与
  * 周期窃取 - CPU访问总线较少，不用的时候可以给DMA用
* I/O通道 将I/O指令单独由通道包含处理器执行
  * 可控制多台不同类设备
  * 流程：cpu遇到I/O，启动通道-cpu执行其他-通道完成后发出中断-CPU处理I/O 【并行】

总线

* 单总线 ： 易于扩充。｜ 传输时延大，串行
* 传统三总线 ：CPU与I/O隔离，支持更多I/O设备 ｜ 没把I/O分开，速率差别大不幸
* 南北桥：支持不同速率I/O
* 通道多级总线：好

从下至上 IO软件

* 高效率，通用性
* 设备无关性，出错处理，同步/异步传输，缓冲技术

* 中断处理程序：检查设备状态寄存器，根据情况处理
  * 错：向上报告错误，重新执行
  * 正常：唤醒等待进程，转换为就绪态
  * 等待：有等待传输I/O，通知启动下一个I/O请求
* 设备驱动程序
  * 逻辑I/O 转化为 物理I/O 操作
  * 监督 是否 正确执行，纠错， 管理数据缓冲区
  * 功能： 设备初始化，执行设备驱动例程，调用和执行中断程序
  * 只处理一种设备，或一类紧密相关的设备
  * 整体（不移植） ， 分层（移植，开销增加）
* 独立于设备的I/O软件：适用所有设备，向用户层提供接口
  * 命名，保护，提供数据单位，缓冲，分配状态跟踪，错误处理报告
* 用户空间的I/O软件
  * 库函数（用访管指令陷入内核，内核函数实现 I/O操作
  * Spooling 内核外的系统I/O

I/O缓冲

* 解决速度不匹配
* 单缓冲：数据-缓冲区-用户区-应用程序 ｜ 写：用户区复制到缓冲区
* 双缓冲：一个供用户程序使用，另一个可继续输入输出
* 循环缓冲：链表

设备独立性

* 逻辑设备 - 物理设备 独立开，调用类而不是单个设备
* 提高灵活性，隔离性，
* 每类对应设备类表中的一栏

磁盘

* T~a~=T~S~+1/2r+b/rN  
  * Ta 存取时间 Ts 寻道时间，r磁盘旋转速度（转/秒），B传送字节数，N一个磁道中的字节数

* 移动臂调度
  * 调度策略：先进先出（低效），最短查找时间优先（饥饿）
  * 扫描算法：单向，双向，电梯调度（当前移动方向没有，反向有请求时，反向）
* 旋转调度
  * 优化分布：循环排序；优化排列，交叉分布（读取有延迟），按柱面数据读写

虚拟设备：

* 使用一类物理设备 模拟 另一类物理设备

SPOOLing

* 磁盘开辟输入井和输出井，有预输入程序，预输出程序，井管理程序
* 预输入：作业开始前数据预先输入磁盘缓冲区，省去启动输入设备时间
* 缓输出：输出存在缓冲区，作业执行完，再由操作系统成批处理
* 将 独占设备 变为共享设备 “假脱机真联机”
* -（预输入）-输入状态 -（预输入完成）- 收容状态 -（作业调度，选中并创建进程）
* 执行状态（进程运行） -（作业调度，终止撤离）- 完成状态-（缓输出）-

## 内存管理

段式程序设计- 段覆盖技术（不相关程序替换执行完代码）

复用 - 分区复用，页架复用

地址转换： 逻辑-物理 静态/动态

空间 分去配， 利用主存分配表

存储保护：权限，地址保护异常

存储扩充：对换技术（不运行进程调出），虚拟技术（只调入部分内容）

虚拟技术：随用随调入，容纳进程装入，主存负责进程执行，对用户透明

Cache：由SDRAM，联想存储器，地址转换部件，替换逻辑组成

* L1 ：数据缓存 和 指令缓存
* L2 : 内置和外置
* L3 : 多为外置

存储管理基本模式

* 单连续存储管理（不可虚拟）

  * 主存分为系统区，用户区
  * 栅栏寄存器
  * 静态重定位
  * 适用单用户单任务

  固定分区存储管理：分区数量，大小固定，主存分配表，可动态重定位，有内存内零头

  可变分区：已分配区表和未分配区表（链表），内存回收，移动分区（基于动态重定位）

* 段式存储管理

  * 逻辑地址：段号：单元号
  * 段表项：始址，限长，标志位
  * 共享：不同进程段表项指向同一个段基址 并加保护
  * 虚拟存储：动态装入，与段覆盖不同，用户控制，OS不感知

* 页式存储管理

  * 物理：页架 ｜ 逻辑：页 ｜ 可不连续 
  * 页表：页 -  页架 一一对应
  * 逻辑地址：《页号，单元号》
  * 位示图：记录主存分配情况
  * 共享：不同进程可以使用不同页号共享数据页，但必须使用相同页号共享代码页（否则JMP《页内地址》失效） 
  * 快表：Cache（联想存储器）中的部分页表
  * 进程表：标记 进程，页表始址，页表长度

  虚拟存储：

  * 首次只把进程第一页装入 ：请求页式存储管理
  * 扩充页表项：虚拟地址，实际地址，标志位
  * 实现：CPU处理不在主存，缺页中断；OS处理吊入空闲页架或调出其他页

* 段页式存储管理

  * 每一段不必占据连续存储空间，可离散存放在主存页架中
  * 段表项：标志，页表长，页表始址
  * 逻辑地址：段号，页号，单元号
  * 快表无，查询过程：查段表得到页表，页号为偏移量，查到块号，+单元号得到物理地址

页面调度：

* 缺页中断率：不成功访问/总访问
* 影响⬆️：可用页架数，页面大小 ，算法
* OPT：优先淘汰下一次访问离这次最远的页面
* FIFO：优先淘汰最先调入主存的那一页
* LRU：优先淘汰最久未被访问
* CLOCK：循环队列

反置页表

* IPT：MMU用的数据结构

* 页表项：页架号代表序号，页号，进程标志符，标志位

*  **MMU**通过哈希表把进程标识和虚页号转 换成一个哈希值，指向**IPT**的一个表目

  **MMU**遍历哈希链找到所需进程的虚页号， 该项的索引就是页架号，通过拼接位移便可生成物理地址

  若遍历整个反置页表中未能找到匹配页表项，说明该页不在内存，产生缺页中断， 请求操作系统调入

## 中断 与 系统结构

###  寄存器

* 用户程序可见寄存器：数据，地址（栈指针等）
* 控制与状态寄存器：PC，CC，标志位等
* 程序状态字 PSW，

### 指令

* 取指，译码，执行
* 特权指令（OS内核使用），非特权：用户可用
* 处理器模式：
  * 用户-内核 ： 系统调用，异常，响应中断
  * 内核-用户 ： 中断返回指令

### 中断

* 操作系统 “中断驱动”，中断是激活操作系统唯一方式
* 狭义中断（处理器之外中断），异常（运行指令中断），系统异常（系统调用）
* 中断系统：硬件子系统（中断响应），软件子系统（中断处理）
* 指令执行周期最后增加 响应中断操作
* 中断装置 ： 发现并响应中断
  * 处理器外的中断:由中断控制器发现和响应
  * 处理器内的异常:由指令的控制逻辑和实现线路发现和响应，相应机制称为陷阱
  * Syscall: 处理器执行陷入指令时直接触发，相应机制称为系统陷阱
* 中断控制器：控制 和 寄存器
  * 寄存器记录中断 ，指令处理最后检查寄存器
* 陷阱 与 系统陷阱
* 中断响应过程：
  * 检查中断寄存器，是否该屏蔽，根据优先级选择
  * 保存 PSW/PC 到 核心栈
  * 转到 中断处理程序
* 中断处理
  * 保护处理器状态
  * 识别中断源
  * 处理中断
  * 恢复正常操作 - 返回中断进程 或 调整进程队列
* 多中断处理： 屏蔽 ，优先级，嵌套（《=3，可能改变处理顺序）

## 进程

进程 ： 动态 ， 资源分配和调度的基本单位

包括：OS管理的数据结构P，内存代码C，内存数据D，通用寄存器信息R，程序状态字PSW

可再入程序：相同代码不同数据集，纯代码

不同时间中针对 同一个程序运行 形成两个不同的进程

进程状态：

* 运行态，就绪态，等待态

*  ```mermaid
  graph TD
  A(运行态) -->|落选| B(就绪态)
  B(就绪态) -->|选中| A(运行态)
  C(等待态) --> |等待事件结束|B(就绪态)
  A(运行态) --> |出现等待事件| C(等待态)
  ```

* 挂起

进程控制块 PCB：

* 标识信息  - 现场信息（寄存器） - 控制信息

进程映像（内存映像）： PCB，程序块，数据块，核心栈

进程上下文：用户级，寄存器，系统级

队列管理模块：进程管理核心模块

进程控制与管理：

* 进程创建:进程表加一项，申请PCB并初始化， 生成标识，建立映像，分配资源，移入就绪队列
  • 进程撤销:从队列中移除，归还资源，撤销标识， 回收PCB，移除进程表项
  • 进程阻塞:保存现场信息，修改PCB，移入等待 队列，调度其他进程执行
  • 进程唤醒:等待队列中移出，修改PCB，移入就 绪队列(该进程优先级高于运行进程触发抢占)
  • 进程挂起:修改状态并出入相关队列，收回内存等资源送至对换区
  • 进程激活:分配内存，修改状态并出入相关队列
  • 其他:如修改进程特权

#### 进程切换：

中断触发 ，压入PSW/PC

处理中断

被中断进程 保存值， 状态调整，加入队列

选中下一个进程

调整恢复，选中进程

中断返回，弹出PSW/PC

## 线程

单线程（进程）问题：进程切换开销大，进程通信开销大，限制了进程并发的粒度，降低了并行计算的效率

将进程 资源分配 和 系统调度分派执行分离开：

* 进程 ： 系统资源分配 和保护的独立单位，不需频繁切换 （容纳进程映像，存取保护）
* 线程 ：系统调度和分配的基本单位，能轻松的被频繁地调度和切换
  * 具有：线程执行状态，受保护的上下文，独立程序指令计数器，执行堆栈，静态存储器（局部变量）
  * 状态：运行，就绪，睡眠

并发多线程优点： 快速线程切换，减少系统管理开销，线程通信易于实现，并行程度提高，节省内存空间

KLT：内核调度方便，本身也可多线程，但是应用程序线程在用户态，控制权切换需要模式切换，开销大

ULT：节省模式切换开销，不打扰内核，程序管理；运行在任何OS；缺点：不能利用多处理器，引起进程堵塞

* 可用 jacketing 程序 来决定 进程切换 或 传递控制权给另一个线程
* 内核只负责进程调度

ULT：逻辑并行性 KLT：物理并行性

混合模式：多个ULT映射一些KLT

## 处理器调度

高级调度：能否加入到执行的进程池中 （多新建 终止）

中级调度：决定主存中的可用进程集合 （带 挂起）

低级调度：决定哪个可用进程占用处理器执行 （原三态）