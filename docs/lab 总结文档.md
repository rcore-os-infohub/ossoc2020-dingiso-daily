# lab 简单总结

## lab-0 简单总结

1. 为了借用新的特性 nightly
2. std 依赖操作系统 `#![no_std]` 禁用
3. `panic_handler` 也在std库中，但是在运行过程中必须实现，所以我们自己写一个
4. 异常时是要通过堆栈反向**捕获异常**并**清理现场**的，暂时不需实现，所以panic直接终止
5. `main`函数并不能作为操作系统入口，所以我们用`_start` 函数代替，并利用 `extern "C"` 和 `# [no_mangle]` 来使得他成为入口函数
6. 通过改变链接器参数，使得程序编译成不依赖其他运行时环境的裸机目标
7. 对于一个OS内核，他的起始地址和普通程序不同，在高地址上，通过更改-链接脚本
8. 通过更改链接脚本使得，内核放在正确的地址上，并依次按顺序排放，`_start` 在先.
9. 内核运行还需要环境支持，所以我们用汇编重写`_start` ，分配启动栈，并跳转到内核入口
10. 将汇编代码内联到`main.rs`中，并更改内核入口为`rust_main`
11. 建立`Makefile` 保存编译运行参数，方便直接调用运行
12. OpenSBI 所提供的`SBI`调用参数 **0-8** ，为我们提供操作操作系统的基本功能
13. 输出功能利用`core`中的输出函数调用`SBI`的单字符输出，并利用`println`等宏进行封装
14. 完善 `panic` 和 `abort` 功能

## lab-1 简单总结

1. 中断处理首先要保存上下文(即寄存器)在栈中,并在中断后恢复,分为两部分: 
   * context :通用32个寄存器,保存触发中断的指令地址`sepc`和系统状态的`sstatus`
   * 单列 :保存中断主要信息和原因的 `scause` 和 `stval`,因为后面需要使用所以单独
2. 利用汇编将寄存器的值存储在栈中,注意栈寄存器`sp`就是`x2`,所以需要空出他
3. 利用 `STIE` 位开启时钟中断,利用 `sstatus` 的 `SIE` 位,允许内核态被中断打断
4. 通过`sbi_call` 可以预约下一次的时钟中断,`time`参数就是中断时间
5. 总结 时钟中断的调用过程
<img src="https://github.com/dingiso/DailySchedule/img/TimeInterrupt.png"  alt="时钟中断" />
## lab-2 简单总结

1. 对于动态内存分配，我们需要实例一个`堆`对象，而这个对象必须具有以下特征

   * 实现 `Trait GlobalAlloc` 的分配功能
     * 实现 `alloc` 和 `dealloc` 函数  ， 要求分配连续`size`大小，满足`align`对齐
   * 使用语义项`#[global_allocator]`进行标记

   编译器便会自动使用我们提供的内存分配函数

2. 先开辟一个`u8`数组，将首地址和长度付给我们定义好的堆对象即可

3. 探寻内核使用的结尾地址，`linker.ld` 说明了结尾地址为 `kernel_end` 我们将此函数实现，并将他的地址 作为 `usize` 输出皆可。

#### 物理页的管理与分配

1. 页首地址满足 4kB 的倍数 ，页号 x4096 = 页首地址

2. 分配的地址不存在堆或栈中，我们利用`FrameTracker`封装，实现类似于`Box` 的智能指针的相关特性，相当于我们对**页**实现了以下操作：

   * 封装了 `&'static mut` 类型的引用
   * 提供了 `Drop` 函数，存在生命周期，超出后自动析构
   * 需要引用计数则外面封装 [`Arc`](alloc::sync::Arc) 

3. 针对所有的物理页，我们实现了一个物理页分配器封装对页的操作

   ```rust
    pub static ref FRAME_ALLOCATOR: Mutex<FrameAllocator<AllocatorImpl>> = Mutex::new(FrameAllocator::new(Range::from(PhysicalPageNumber::ceil(PhysicalAddress::from(*KERNEL_END_ADDRESS))..PhysicalPageNumber::floor(MEMORY_END_ADDRESS),)));
   ```

   **`Mutex<FrameAllocator<AllocatorImpl>>`** 

   * `Mutex`对分配器加锁防止多个线程访问，

   * `FrameAllocator` 为主要分配器，

   * `AllocatorImpl` 为分配器算法。

   `PhysicalPageNumber::ceil(PhysicalAddress::from(*KERNEL_END_ADDRESS))..PhysicalPageNumber::floor(MEMORY_END_ADDRESS)`

   分配器分配的内存范围从 `kerne_end` 结束（上取整）开始到 我们可访问内存的最后的（下取整）

4. 分配器算法利用的是实际物理页和起始地址的偏移量

## lab-3 简单总结

### 基础内容 - 关于页表

### 首先： 为什么要用到虚拟地址？

简单理解，这是为了方便程序编写者的一种方法。比如我的程序想要运行在这个操作系统上， 我希望不需要考虑操作系统的实际内存情况，难道我还要看一下操作系统的代码，或翻一下手册么？ ， 我希望我的程序用的就是从 `0x1` 开始的连续地址，那么这个 `0x1` 就是虚拟地址。

### 页表：

但是在操作系统中，实际运行时是需要使用实际物理地址的，那么我们如何推算物理地址呢，我们可以将这种（虚拟地址-物理地址）看作一种函数（映射）关系
`f (虚拟地址）= 物理地址` 在存储时 就有了两种储存的方法，

1. 第一种 我们将这个 `f` 函数（简单理解是个线性的）关系储存下来 - 也就是 最开始[修改内核](https://rcore-os.github.io/rCore-Tutorial-deploy/docs/lab-3/guide/part-2.html) 中使用的方法， 只需要统一加一个 偏移量即可。
2. 第二种 我们将每一个 （虚拟地址-物理地址） 也就 (x,y) 按对存储起来，通过查找 虚拟地址，便能获得相应的物理地址。

第二种方法便是我们所说的页表 ， 他是一（多）张，存储这种关系的表，通过查表便能完成 查找物理地址的任务。

> 而且，虚拟地址也是对物理的地址的一种封装方法，可以实现内核对物理地址的权限管理，也就是我们在页表项的标志位，假设我不希望系统内核所在的地址被其他人写入其他内容，我只需要在页表项上

### 多级页表：

这种方法主要是为了节省内存，同时可以方便我们不用跨物理页去查询这张表。那么他为什么可以节省内存呢？
**举个小栗子：** 内核代码在虚拟地址里 是 `0xffffffff80200000` ， 在实际物理地址是 `0x80200000` ， 在普通页表中我要这么存储， `(0xffffffff80200000,0x80200000,flag)` 这样的。同样在表示内核以 0xffffffff 开头的虚拟地址还有很多，这样会无形中增加很多的空间开销，但我们知道不断存储 `0xffffffff` 是冗余的。所以我们利用分级的方法，可以把页表变成下面的形式（理解方法）：

- 二级页表 `（0xffffffff（虚拟地址的高位），存储下面一级页表的物理页号（首地址） ）`
- 一级页表 `（0x80200000（低位），0x80200000（物理地址））`
  通过二级页表查找到一级页表的存储位置，再通过低位找到对应的物理地址。

**那么**我们实际上对于所有 以开头 `0xffffffff` 开头的虚拟地址，二级页表中永远只有一个页表项，这就节省了原来每次都要把他写上的空间。

### 代码部分

1.  更改 linker.ld 的数据存放起址改为虚拟地址，并在各字段加入对齐，使得一个虚拟页不会有两个段。目的是为了可以对每一个段赋予不同的属性

2. entry.asm 中利用  下面代码使得 CPU模式 变为 Sv39

   ```assembly
   # 8 << 60 是 satp 中使用 Sv39 模式的记号
       li t1, (8 << 60)
       or t0, t0, t1
       # 写入 satp 并更新 TLB
       csrw satp, t0
   ```

   

3. 给出内核使用线性映射的偏移量 并 在 entry.asm 中 建立一个boot_page_table 作为初始页表，

   * 第一个映射是 0x8000_0000 -> 0x8000_0000 VPN3 是 10B 所以放在第三位
   * 第二个映射是 0xffff_ffff_8000_0000 -> 0x8000_0000 VPN3 是 111111110B 所以放在 510位
   * 保存第一个映射是违反规则的，但是为了执行 这个asm内的代码，所以要存在这个映射。

4. 将虚拟地址 分为 `0..9 的VPN1` `9..18的VPN2` `18..27的VPN3`

5. **页表项  ：PageTableEntry = 标志位+页号**   |对 物理页号进行封装

6. **页表 ：PageTable** |装满一个物理页的页表项数组

7. **页表智能指针：PageTableTracker** 因为页表太大了，所以利用上文提供的工具 `FrameTracker` ，将这个页表当成一个物理页看待，利用“智能指针”对其进行操作。

8. **内存段：Segment** |在很多情况下虚拟页的单位量级太小了，我们对内存的管理可能一次涉及很多页，为了简化操作，我们将很多虚拟页统一封装为一个`Segment`，它具有以下属性

   * 两种简单的映射类型 ： 线性映射 和 每一帧都有映射
   * 映射到的一块连续的虚拟地址
   * 统一的权限标识

9. **实际应用的映射关系：Mapping** | 完成了基础的结构定义，那么我们该实际的对每个线程的映射关系进行封装并完成实际的操作和结构了：

   * 保存了 页表向量 ， 根页表物理页号， 映射信息
   * `find_entry()` 实现 给定虚拟页号查找物理页号
   * `map()` 实现了实际数据（未写入页中）的写入并构建映射
     * 线性则利用 我们`address.rs` 中规定的方式直接转换
     * `Framed` 则 分割数据 ， 更新页表，写入物理页， 将映射关系写入映射
   * `activate()` 实现了将页表起使地址写入`satp` ，使用`Sv39`模式并 刷新`TLB`

10. **实现内核的重映射 ：MemorySet** ： 利用我们工作替代原来的蛮夷，

## lab-4

1. **线程：Thread** | 线程是我们关注的实际**执行代码的单位**，教程的定义包括

   * 线程 ID  - 唯一标识线程的身份

   * 线程的栈 - 线程占有一段的虚拟空间来进行利用

   * 所属的进程

   * 代表自身情况的可变变量（`Mutex`）- 包括 运行上下文，是否休眠，结束等属性 ， 

     > 利用 `Mutex` 来包装使得 `Arc<Thread>` 保存的线程中的这些值可以被我们使用。

2.  **进程： Process** | 资源调度的基本单位，只需要保存自身属性和 线程共享页表，内存空间即可

   * 属于 用户态 还是 内核态
   * 共用的 一块 内存空间，页表

3. **线程管理器：Processor** | 存放和管理所有的线程，主要包括：

   * 正在执行的线程
   * 调度器 对线程实现调度，包括线程的添加，移除，进行下一个
   * 休眠线程-处于等待状态的一些线程

   实现全局的，由`Lock`封装的管理器，我们利用`Mutex`和 `关闭时钟中断`  保证他一直在线

4. 通过设置`Context`进行一个小的实验，进行验证并执行
   * `mv sp a0`  ,  通过 `__restore` 传入一个参数-即我们精心涉及的`Context`
   * 原来我们是在实验中为了验证中断而开启了中断，现在我们将其放在了线程开始时

5. **中断处理** ： |   线程切换实际为时钟中断的过程，我们需要在中断处理时完成切换

   * 定义的管理器`PROCESSOR`完成当前线程的 上下文 的保存
   * 管理器为我们分配下一个应该调用的进程，并将他的上下文返回 通过 `__restore` 转换
     *  如果没有下一个线程，则启动休眠线程，都没有则退出

6. **线程的结束：**| 通过设置 `ra` 时线程顺利结束 

   * 原来线程结束触发`Exception::InstructionPageFault`  ，跳转 `0x0`
   * 通过触发中断，通知操作系统进行释放，`ecall` 调用 `ebreak`
   * 将中断包装在结束函数中，标记线程结束，并设置线程结束的 `ra`

7. **内核栈：** | 但发生中断时，会切换到内核态，原来用于处理中断的`sp`指针需要一个内核栈，专门用于在内核态执行函数 - 防止线程的崩溃导致操作系统的崩溃

   * 只需要一个内核栈，因为只有中断时使用内核栈，而不会有两个线程同时中断
   * 内核栈的地址不能放在通用寄存器中，而`sscratch`只有内核态能访问，比较合适
   * 实际的做法: 定义`kernel_stack`分配空间，`interrupt.asm`中对`sscratch`操作
     * 为内核栈分配一段空间
     * 运行线程时，将内核栈指针保存在`sscratch`寄存器中
     * 中断时，则从将 `Context` 压入 `sscratch` 指向的栈中（`Context` 的地址为 `sscratch - size_of::<Context>()`），同时用新的栈地址来替换 `sp`（此时 `sp` 也会被复制到 `a0` 作为 `handle_interrupt` 的参数）
     * 从中断中返回时（`__restore` 时），`a0` 应指向**被压在内核栈中的 `Context`**。此时出栈 `Context` 并且将栈顶保存到 `sscratch` 中

      运行时如何 将内核栈指针保存在`sscratch`中?

<img src="https://github.com/dingiso/DailySchedule/img/sscratch.png"  alt="sscratch" />

## lab-5

1. 不能一直运行内核 ，我们要实现把读取存储设备的数据，**OpenSBI** 进行扫描并设备通过**MMIO**映射到物理内存的一块了，我们只需要在rust_main 中添加参数，OpenSBI 就会告诉我们映射的地址

   * `_hart_id`:  0,

     `dtb_pa`:  PhysicalAddress(0x82200000)

2.  通过调用 rcore 中的 属性解析`device_tree`库，我们得到的便是一个 建好的树  - **设备树**

   * 通过 递归 从根节点进行递归 ，发现支持 `"virtio,mmio"` ， 就可以加载他的驱动
   * 初始化设备 时需要进行验证`Magic Number` ， 确定其为设备树

3. 进一步对节点进行判断， 只读取其中的 `Block` 块设备

   * 粒度 为 整**块**，以块为单位读写，（类比硬盘）

4. 实现为 `DMA` 分配物理页的定义和操作 包括 **物理地址-虚拟地址的转换**， **分配和去配操作**

5. 抽象设备 驱动的接口 ，简单的三种方法 ：

   * 读取设备信息
   * 块设备接口
     * 读取某个块 到 buffer 中， 实现对数据的读取
     * 将 buffer 的数据 写入 某个块， 实现写数据

6. 对块设备的抽象，基本为实现上述 的 三个接口。

  <img src="https://github.com/dingiso/DailySchedule/img/design.png"  alt="design" />

   

7.  文件系统 利用 rcore-fs 通过查找全部设备驱动中的第一个存储设备作为根目录。
8. 同时调用`BlockCache::new()` 使得设备在内存中具有`cache`
9. 最后 通过 调用 以实现的接口中的 `ls` 进行 文件名的输出

## lab-6

1. 建立 `user` crate，作为用户程序的放置位置 - 并为其去除依赖

2. 通过 `rcore-fs-fuse` 将我们的用户程序编译打包为 **ELF** 文件-转换为 **QCOW_FILE** 格式

3. 利用 `xmas_elf` 解析器将 ELF 文件读到内存中，解析字段，建立**内核映射**（能中断）

4. 修改`Mapping::map` 函数 ， 增加 `init_data`参数为初始化数据
   * 动态分配内存 - 分配的不一定连续 - 利用**帧分**配的方式
   * 考虑 如果最后剩下的数据不满足一页的情况
   * 加载到内存时， 对 `.bss` 段进行初始化
   
5. 利用汇编参数的传递，实现系统调用，从相应的寄存器中取出调用代号和参数，根据调用代号，进入不同的处理流程，得到处理结果

   * 回数值并继续执行：
     * 返回值存放在 `x10` 寄存器，`sepc += 4`，继续此 `context` 的执行

   * 程序进入等待
     * 同样需要更新 `x10` 和 `sepc`，但是需要将当前线程标记为等待，切换其他线程来执行

   * 程序终止
     * 不需要考虑系统调用的返回，直接删除线程

6. 编写文件的输入输出流 `stdin` `stdout`
7. 实现条件变量，替代原来的阻塞式，增加处理器利用率，增强交互性

