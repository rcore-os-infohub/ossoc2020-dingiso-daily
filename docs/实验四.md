# 实验四

1. 原理：线程切换之中，页表是何时切换的？页表的切换会不会影响程序 / 操作系统的运行？为什么？

   1）线程结束时，ra 结束函数触发时钟中断，中断处理函数调用 `prepare_next_thread()` , 在实际调用 `next_thread.prepare()`  最后通过 `activate()` 激活页表，进行页表的切换

   2）不会影响运行，页表切换发生在中断期间，操作系统运行中，我们设立了内核栈，中断期间调用的，一直存在。

2. 设计：如果不使用 `sscratch` 提供内核栈，而是像原来一样，遇到中断就直接将上下文压栈，请举出（思路即可，无需代码）：

   - 一种情况不会出现问题    - 不操作 sp 
   - 一种情况导致异常无法处理（指无法进入 `handle_interrupt`）- 不保存 sp 寄存器
   - 一种情况导致产生嵌套异常（指第二个异常能够进行到调用 `handle_interrupt`，不考虑后续执行情况） - 运行两个线程。在两个线程切换的时候，会需要切换页表。但是此时操作系统运行在前一个线程的栈上，一旦切换，再访问栈就会导致缺页，因为每个线程的栈只在自己的页表中
   - 一种情况导致一个用户进程（先不考虑是怎么来的）可以将自己变为内核进程，或以内核态执行自己的代码 -  通过 改变 sp 的存储位置， 使得用户进程有能力访问并修改到

3. 实验：当键盘按下 Ctrl + C 时，操作系统应该能够捕捉到中断。实现操作系统捕获该信号并结束当前运行的线程（你可能需要阅读一点在实验指导中没有提到的代码）

   [handler.rs](https://github.com/dingiso/DailySchedule/blob/master/code/实验四/handler.rs)

    通过开启外部中断的方法， 借助 sbi 调用函数，捕捉键盘导致的外部中断，先在  中断处理时打印 ctrl+c 的 sbi 调用返回值，为3 ，判断其为 3 则 `kill_current_thread`