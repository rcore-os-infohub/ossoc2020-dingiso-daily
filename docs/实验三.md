# 实验三

1. 原理：在 `os/src/entry.asm` 中，`boot_page_table` 的意义是什么？当跳转执行 `rust_main` 时，不考虑缓存，硬件通过哪些地址找到了 `rust_main` 的第一条指令？

   1） 因为我们将内核统一使用虚拟地址，所以需要一个初始的页表进行映射，也就是题中所说的`boot_page_table`， 因为他的asw 不全为0 ， 它包含了 两个 1GB 大页 分别表示映射

   | 虚拟地址                                    | 物理地址                  |
   | ------------------------------------------- | ------------------------- |
   | 0x8000_0000 - 0xC000_0000                   | 0x8000_0000 - 0xC000_0000 |
   | 0xffff_ffff_8000_0000-0xffff_ffff_c000_0000 | 0x8000_0000 - 0xc000_0000 |

   第二项 为  我们以后将要使用的虚拟地址 与 物理地址之间的映射

   第一项 是因为我们 在 替换页表后，pc 仍不会改变，所以需要先行利用这个继续运行，带pc改变后，改为 第二个映射

   2）先从 satp 高位读取内存的映射方式，低位读取 `boot_page_table` 的物理页号，

   读取 VPN3 【30：38】  `0xff` 为  `111111110`  为 510 定位到 510项， 判断页表项得知为大页

   从表中知道物理页基址为 0x8000_0000 加上，页内偏移量，找到了 `rust_main()` 的地址

2. 分析：为什么 `Mapping` 中的 `page_tables` 和 `mapped_pairs` 都保存了一些 `FrameTracker`？二者有何不同？

   page_tables   存放页表会用到的页面

   mapped_pairs 存放所有映射过的页面， 进程用到的页面

3. 分析：假设某进程需要虚拟地址 A 到物理地址 B 的映射，这需要操作系统来完成。那么操作系统在建立映射时有没有访问 B？如果有，它是怎么在还没有映射的情况下访问 B 的呢？

   没有访问B，我们需要申请建立页表时，会得到 B 的物理地址，但特殊情况， 如果B是内核地址，我们可以直接通过线性偏移量进行访问。

4. **实验框架尚未准备完善）**实验：了解并实现时钟页面置换算法（或任何你感兴趣的算法），可以自行设计样例来比较性能

   - 置换算法只需要修改 `os/src/memory/mapping/swapper.rs`，你可能需要在其中访问页表项

   - [swapper.rs](https://github.com/dingiso/DailySchedule/blob/master/code/实验三/swapper.rs) 

   - 在 `main.rs` 中调用 `start_kernel_thread` 来创建线程，你可以任意修改其中运行的函数，以达到测试效果

     为确保`PageTableEntry` 安全传输 - 为时钟swapper 实现 send 接口

     在pop 的时候，如果该页表项`PageTableEntry` 以访问（ACCESS=1） 或者 已修改 （DIRTY=1） 就将其置零

     否则， 就将其替换掉

